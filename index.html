<!DOCTYPE html>
<html>

<head>
<meta charset='utf-8' />
<meta http-equiv="X-UA-Compatible" content="chrome=1" />
<meta name="description"
	content="Js-class-loader : (Java) Fast Javascript aggegator / bundler, with dependency detection." />

<link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">
<link rel="shortcut icon" href="favicon.ico" />
<title>JS-Class-Loader</title>
</head>

<body>

	<!-- HEADER -->
	<div id="header_wrap" class="outer">
		<header class="inner">
			<a id="forkme_banner" href="https://github.com/damonsmith/js-class-loader">View on GitHub</a>

			<h1 id="project_title"><a href=".">JS-Class-Loader</a></h1>
			<h2 id="project_tagline">(Java) Fast Javascript aggregator / bundler. With dependency detection.</h2>
			The javascript weapon of a more civilized age.

			<section id="downloads">
				<a class="zip_download_link" href="https://github.com/damonsmith/js-class-loader/releases/latest">
					Download the latest release jar file
				</a> 
				<a class="tar_download_link" href="https://github.com/damonsmith/js-class-loader/tarball/master">
					Download this project as a tar.gz file
				</a>
			</section>
		</header>
	</div>

	<!-- MAIN CONTENT -->
	<div id="main_content_wrap" class="outer">
		<section id="main_content" class="inner">

			<ul class="menu">
				<li><a href="config-options.html">Config options</a></li>
				<li><a href="troubleshooting.html">Troubleshooting</a></li>
				<li><a href="feedback.html">Feedback</a></li>
				<div style="clear: both"></div>
			</ul>

			<div>
				<h1>Fast overview</h1>
				<p>A Java program to bundle together your javascript and generate source maps by inspecting the code for dependencies.</p>
				<p>
				Some javascript codebases use a Java style class structure, where each class is in a file with the same name as the class inside it,
				and each class namespace matches the folder tree that it is in. A project may have many modules and source roots
				but inside each one the code is organised in a java style class/package structure.  
				</p>
				<p>
				If your project structures it's code in this way, then this bundler will automatically detect dependencies and include
				them. And if you use the standard extends() function for class inheritance, then this bundler will automatically 
				know to generate the dependency list in the right order.
				</p>
				<p>
					E.g: imagine ypur source roots are script/ and modules/* (so that each folder in modules is a source root)<br /> 
					script/app/Main.js contains the class app.Main<br />
					modules/audio/lib/audio/Sampler.js contains the class lib.audio.Sampler<br />
					modules/services/lib/rest/DataService.js contains the class lib.rest.DataService<br />
				</p>
				
				<p>
				If app.Main uses the class audio.lib.Sampler then the bundler will see that and know to include the Sampler class.
				You don't need to specify it or manually list your classes dependencies.
				If some of your code doesn't conform to the standard structure then you can manually include it with the include
				function.
				</p>
				
				<p>It is written in Java and works as either a command line tool (which can run as a watcher while you code) 
				a builder inside your IDE, a server side generator in Java apps, and as a step in your build. 
				</p>
			</div>

			<div>
				<h1>How to run it - </h1>
				<h2>Try it out on the command line</h2>
				<p>You need to have Java 1.7 or higher installed. Then find a seed class, source folder and output file, and run the bundler like this:</p>
				
				<code>java -jar js-class-loader-1.2.17.jar --sourcePaths=src --seedClasses=my.app.Main --bundleFile=gen/bundle.js</code>
				
				<p>Check your output file to see what's in there.</p>
				
				<h2>Move your config into a config file</h2>
				<p>Once you've got the basic bundling going on the command line, put your config options into a js-class-loader.properties file, and put it
				it wherever you keep your config files. Add the basePath option into your config file to make sure it always runs from the right place.</p>
				<p>You can then run the bundler again with</p>
				
				<code>java -jar js-class-loader-1.2.15.jar --config=conf/js-class-loader.properties</code>
				
				<h2>Run it as a file watcher</h2>
				<p>Sometimes an out-of-IDE process to bundle your code is the most effective way. To run JSCL like this, add --watchFiles=true on the command line</p>
				
				<code>java -jar js-class-loader-1.2.15.jar --config=conf/js-class-loader.properties --watchFiles=true</code>
				
				<h2>Run it from your IDE</h2>
				<p>In eclipse you can set up a project builder that runs the jar and specifies the arguments. Use the same arguments as you would from the command
					line.</p>
				
				<h2>Add it to your Maven build</h2>
				
				<p>Add the following dependency to your pom.xml dependencies section:</p>
				<code>
				&lt;dependency&gt; <br />
				&emsp;&emsp;&lt;groupId&gt;com.larrymite&lt;/groupId&gt; <br />
				&emsp;&emsp;&lt;artifactId&gt;js-class-loader-mojo&lt;/artifactId&gt; <br />
				&emsp;&emsp;&lt;version&gt;${pom.version}&lt;/version&gt; <br />
				&lt;/dependency&gt; <br />
				</code>
				
				<p>And add the following plugin to your build/plugins in your pom.xml file:</p>
				
				<code>
					&lt;plugin&gt;<br />
					&emsp;&emsp;&lt;groupId&gt;com.larrymite&lt;/groupId&gt;<br />
					&emsp;&emsp;&lt;artifactId&gt;js-class-loader-mojo&lt;/artifactId&gt;<br />
					&emsp;&emsp;&lt;version&gt;${pom.version}&lt;/version&gt;<br />
					&emsp;&emsp;&lt;executions&gt;<br />
					&emsp;&emsp;&emsp;&emsp;&lt;execution&gt;<br />
					&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&lt;goals&gt;<br />
					&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&lt;goal&gt;generate-js-bundle&lt;/goal&gt;<br />
					&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&lt;/goals&gt;<br />
					&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&lt;configuration&gt;<br />
					&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&lt;configFile&gt;${basedir}/src/main/resources/js-class-loader.properties&lt;/configFile&gt;<br />
					&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&lt;/configuration&gt;<br />
					&emsp;&emsp;&emsp;&emsp;&lt;/execution&gt;<br />
					&emsp;&emsp;&lt;/executions&gt;<br />
					&lt;/plugin&gt;<br />
				</code>
				
				
			</div>
				
				
			<div>
				<h1>What is the point of all of this?</h1>
				<p>Mainly this tool is for javascript developers working in a java web app environment that want to manage a large js codebase with a neat, 
				convention based code structure without having to worry about manually managing dependencies or installing a suite of other compilers, 
				runtimes and tools to bundle their javascript up. 
				</p>
				<p>No java knowledge is required to run the bundler though, so any developer could use it if they felt inclined.</p>
			</div>
				
			<div>
				<h1>Issues</h1>
				<p>
					Maven integration in eclipse is hard and bad, not just with JSCL but with Eclipse M2E and maven in general. Maven may change files and 
					metadata outside of the project, making it difficult for M2E to guarantee that it's build does the same thing as the maven build. The
					issue is covered in great detail <a href="http://wiki.eclipse.org/M2E_plugin_execution_not_covered">here, in the M2E wiki on "Plugin execution not covered"</a>
				</p>
				<p>
					So the eclipse approach to custom maven plugins is to either force you to add m2e specific config to your project files, which is bad, or write a specific M2E configurator which is bad too,
					and lots of pointless work to keep it working, tested and up to date. Having said all of that, it is possible to use the maven mojo effectively from within
					eclipse, it's just that like with most things eclipse and maven, you might find yourself having to know rather more about maven than you'd like, if you want to fix any 
					random spurious error messages you get when your project gets messed up. Generally I prefer to use the bundler as a builder from eclipse and only use the mojo at
					build time, being confident that the bundles will end up identical. However some developers might get a bit uncomfortable with a bundle file being generated in
					a different way in dev to in the deployed build.
				</p>
			</div>
				
			<div>
				<h1>How fast (or slow) is it?</h1>
				<p>The command line execution process is basically the time it takes for the jvm to start, the files to be read and then a very small amount of time to generate
					the dependency tree and write out the bundle. For projects of under 100 files the command line runner will complete in under a second, for a thousand source files
					it will run in a few seconds. If it is run in file watcher mode then it will be much, much faster again. 
				</p>
			</div>
		</section>
	</div>
</body>
</html>
